---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from util import humanize_bytes
from proofs import *
import matplotlib.pyplot as plt
import numpy as np
```

```{python}
filecoin_scaling_requirements.satisfied_by(bad_performance)
```

```{python}
ec2_x1e32_xlarge.proving_time_per_constraint / porcuquine_prover.proving_time_per_constraint
```

```{python}
porcuquine = ZigZag(security=filecoin_security_requirements, instance=porcuquine_prover)
```

```{python}
x1e32 = ZigZag(security=filecoin_security_requirements, instance=ec2_x1e32_xlarge, partitions=8)
```

```{python}
p = porcuquine.performance()
```

```{python}
pp = x1e32.performance()
```

```{python}
p.total_seal_time
```

```{python}
pp.total_seal_time
```

`pp.total_seal_time` is much higher than `p.total_seal_time` because of 8 partitions and sufficient challenges.

```{python}
humanize_bytes(p.proof_size)
```

```{python}
humanize_bytes(pp.proof_size)
```

```{python}
porcuquine_blake = porcuquine.scaled_for_new_hash(blake2s)
```

```{python}
porcuquine_blake.performance().total_seal_time
```

```{python}
porcuquine.justifies_seal_time(512 * GiB, filecoin_scaling_requirements)
```

```{python}
x1e32.justifies_seal_time(512 * GiB, filecoin_scaling_requirements)
```

```{python}
porcuquine_blake.justifies_seal_time(512 * GiB, filecoin_scaling_requirements)
```

*TODO*
  - [x] check all against a range of seal times;
  - [x] make graphs
  - [x] try with pedersen/blake hybrid, varying `root_height`
  - [x] search space for a combination of `root_height` and sector size which justifies seal time


```{python}
porcuquine_pb50 = porcuquine.scaled_for_new_hash(pb50)
```

```{python}
porcuquine_pb50.justifies_seal_time(GiB, filecoin_scaling_requirements)
```

```{python}
porcuquine_pb50.justifies_seal_time(512 * GiB, filecoin_scaling_requirements)
```

```{python}
porcuquine_pb50.justifies_seal_time(2048 * GiB, filecoin_scaling_requirements)
```

```{python}
porcuquine_pb50.performance().total_seal_time
```

```{python}
porcuquine_pb50.performance(2048 * GiB).total_seal_time
```

```{python}
porcuquine.performance(2048 * GiB).total_seal_time
```

```{python}
porcuquine.performance().total_seal_time
```

```{python}
filecoin_scaling_requirements.total_seal_time
```

```{python}
filecoin_scaling_requirements.proof_size
```

```{python}
porcuquine.performance().proof_size
```

```{python}
x1e32.performance(64 * GiB).proof_size
```

```{python}
x1e32.performance(66 * GiB).proof_size
```

```{python}
x1e32.performance(66 * GiB).total_seal_time
```

```{python}
x1e32.performance(2048 * GiB).total_seal_time
```

```{python}
x1_pb50 = x1e32.scaled_for_new_hash(pb50)
```

```{python}
x1_pb50.performance(66 * GiB).total_seal_time
```

```{python}
x1_pb50.performance(2048 * 4 * GiB).total_seal_time
```

```{python}
x1_blake2s = x1e32.scaled_for_new_hash(blake2s)
```

```{python}
x1_blake2s.performance(66 * GiB).total_seal_time
```

```{python}
x1_pb50.justifies_seal_time(2048 * 4 * GiB, filecoin_scaling_requirements)
```

**We have a first firing solution!**

```{python}
x1_blake2s.justifies_seal_time(2048 * 4 * GiB, filecoin_scaling_requirements)
```

And another. Which has a better (lower) seal time?

```{python}
x1_blake2s.performance(8 * 1024 * GiB).total_seal_time < x1_pb50.performance(8 * 1024 * GiB).total_seal_time
```

We have a winner, and by how much?

```{python}
x1_pb50.performance(8 * 1024 * GiB).total_seal_time / x1_blake2s.performance(8 * 1024 * GiB).total_seal_time
```

Just about double, at that size. Let's try a range, to be sure. TODO: Graph this — but instead of ratio, just include both points and pedersen. Actually just graph a spread of 10 hybrids to make the relationship clear.

```{python}
xs = range(1, 8*1024, 64)
x1_pedersen_seal_times = [x1e32.performance(size * GiB).total_seal_time for size in xs]
x1_pb50_seal_times = [x1_pb50.performance(size * GiB).total_seal_time for size in xs]
blake2s_seal_times = [x1_blake2s.performance(size * GiB).total_seal_time for size in xs]
blake_advantage_pb50 = list(map(lambda pb50, blake: pb50/blake, x1_pb50_seal_times, blake2s_seal_times))
blake_advantage_pedersen = list(map(lambda pedersen, blake: pedersen/blake, x1_pedersen_seal_times, blake2s_seal_times))
```

```{python}
f, (ax1, ax2) = plt.subplots(2,1)
f.set_size_inches(8, 8)
ax1.axis([0, xs[-1], 0, 40000])
ax1.plot(xs, x1_pb50_seal_times, label='pb50')
ax1.plot(xs, blake2s_seal_times, label='blake2s')
ax1.plot(xs, x1_pedersen_seal_times, label='pedersen')
ax1.set_xlabel('Sector Size (GiB)')
ax1.set_ylabel('seal time per GiB')
ax1.legend()
ax2.plot(xs, blake_advantage_pb50, label='blake advantage over hybrid')
ax2.plot(xs, blake_advantage_pedersen, label='blake advantage over pedersen')

ax2.set_xlabel('Sector Size (GiB)')
ax2.set_ylabel('blake2s advantage')
ax2.legend()
plt.show()
```

```{python}
last_diff = None
last_x = None
cross = -1
for (x, blake, pedersen) in zip(xs, blake2s_seal_times, x1_pedersen_seal_times):
    diff = abs(blake - pedersen)
    if last_diff and last_diff < diff:
        cross = last_x * GiB
        break
    last_diff = diff
    last_x = x
            
print(f"Seal rates cross at about {humanize_bytes(cross)}")
cross
```

What's the minimum viable sector size for a 50/50 pedersen/blake2s hybrid on x1e32?

```{python}
humanize_bytes(minimum_viable_sector_size(filecoin_scaling_requirements, x1_pb50))
```

Blake?

```{python}
humanize_bytes(minimum_viable_sector_size(filecoin_scaling_requirements, x1_blake2s))
```

Pedersen?

```{python}
minimum_viable_sector_size(filecoin_scaling_requirements, x1e32)
```

```{python}
minimum_viable_sector_size(filecoin_scaling_requirements, porcuquine)
```

On porcuquine's prover?

```{python}
minimum_viable_sector_size(filecoin_scaling_requirements, porcuquine)
```

On porcquine's prover with blake2s?

```{python}
porcuquine_blake2s = porcuquine.scaled_for_new_hash(blake2s)
humanize_bytes(minimum_viable_sector_size(filecoin_scaling_requirements, porcuquine_blake2s))
```

**Wait, what?**

```{python}
pbp = porcuquine_blake2s.performance(16 * GiB)
pbp.proof_size
```

Bummer, that's a bug. Let's dig into it.

```{python}
porcuquine.performance(16 * GiB).proof_size
```

Actually, it's correct because this is proof-size/GiB. Yay.


Hmmmm… maybe not — proof-size/Gib should change when changing hash.

```{python}
pb2 = porcuquine.scaled_for_new_hash(blake2s)
```

```{python}
pb2.performance(16 * GiB).proof_size
```

```{python}

```
